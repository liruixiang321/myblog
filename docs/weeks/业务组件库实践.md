---
updateTime: "2024-08-20 14:25:26"
desc: "之前做的项目封装了很多业务组件,放在脚手架中，直接进行安装，但是当组件有bug时，需要去每个项目的中组件源码都修改一遍，维护起来困难，所以打算做一个业务组件库，方便以后进行维护😊"
tags: "组件库/前端工程化"
---

# 业务组件库搭建

## monorepo 结构搭建

## 环境配置

## 编程规范（ESlint,prettier,commitlint,sylelint）

## 项目结构以及组件的开发模式

## 组件库打包 📦

整个打包的思路参考开源项目 element-plus,并结合实际的业务场景。进行梳理之后我们需要考虑以下几个问题：  
1.提供浏览器环境可以识别的代码（一般是 UMD 或 IIFE）  
2.提供 Node.js 环境的 CommonJS 规范的代码  
3.提供 ES Module 规范的代码  
4.提供 TypeScript 类型定义文件  
5.提供 CSS 样式文件  
6.提供 sourcemap 文件

### 为什么要提供 cjs 和 esm 两种代码 🏳️‍🌈

- 向后兼容：Node.js 的早期版本主要支持 CommonJS 模块系统。尽管 Node.js 现在也逐渐支持 ESM，但许多旧项目和库仍然使用 cjs 格式。提供 cjs 版本可以确保这些旧项目能够继续运行，无需进行大规模的迁移。

- 生态支持：虽然 ESM 是未来的趋势，但目前并不是所有的工具链和环境都完全支持 ESM。例如，某些构建工具或打包器可能仍然对 cjs 有更好的支持。提供 cjs 版本可以确保这些工具能够无缝地集成和使用库。

- 性能考虑：在某些情况下，cjs 可能提供更优的性能，因为它支持同步加载。虽然这在 Web 应用中通常不是最佳选择，但在 Node.js 环境中，特别是在启动时间不是首要考虑因素的情况下，cjs 可能是一个合理的选择。

- 开发者习惯：开发者对 cjs 和 esm 有不同的偏好。一些开发者可能更喜欢 cjs 的同步加载和更简单的语法，而另一些开发者则可能更喜欢 ESM 的原生支持和更好的静态分析能力。提供两种格式可以满足不同开发者的需求。

下面是尤大在 vite5 发布时对前端未来趋势的总结 🙌：

[!image]("../public/artworks/组件库打包1.png")

### 为产物引入 ts 类型文件（vue-tsc,dts 插件）

### 使用 gulp 单独打包 css 实现 css 按需加载

## 使用 vitepress 搭建组件库文档

## 使用 release 自动管理发布组件库

## 引入 vitest

## CI/CD 持续集成

## 集成 Cli
